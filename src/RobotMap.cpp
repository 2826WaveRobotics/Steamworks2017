// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
std::shared_ptr<SpeedController> RobotMap::intakeIntakeMotor;
std::shared_ptr<SpeedController> RobotMap::intakeShintake;
std::shared_ptr<DigitalInput> RobotMap::intakeIntakeBool;
std::shared_ptr<SpeedController> RobotMap::climbClimbMotor1;
std::shared_ptr<SpeedController> RobotMap::climbClimbMotor2;
std::shared_ptr<DigitalInput> RobotMap::climbClimbBool;
std::shared_ptr<SpeedController> RobotMap::driveDriveMotor1;
std::shared_ptr<SpeedController> RobotMap::driveDriveMotor2;
std::shared_ptr<SpeedController> RobotMap::driveDriveMotor3;
std::shared_ptr<SpeedController> RobotMap::driveDriveMotor4;
std::shared_ptr<RobotDrive> RobotMap::driveRobotDrive41;
std::shared_ptr<SpeedController> RobotMap::driveDriveMotor5;
std::shared_ptr<SpeedController> RobotMap::driveDriveMotor6;
std::shared_ptr<RobotDrive> RobotMap::driveRobotDrive21;
std::shared_ptr<Encoder> RobotMap::driveEncoder2;
std::shared_ptr<Encoder> RobotMap::driveEncoder3;
std::shared_ptr<Encoder> RobotMap::driveEncoder4;
std::shared_ptr<SpeedController> RobotMap::shooterSpeedController1;
std::shared_ptr<AnalogInput> RobotMap::shooterAnalogInput1;
std::shared_ptr<PIDController> RobotMap::shooterPIDController1;
std::shared_ptr<SpeedController> RobotMap::shooterSpeedController2;
std::shared_ptr<AnalogInput> RobotMap::shooterAnalogInput2;
std::shared_ptr<PIDController> RobotMap::shooterPIDController2;
std::shared_ptr<Encoder> RobotMap::shooterEncoder1;
std::shared_ptr<Compressor> RobotMap::gearCompressor1;
std::shared_ptr<Solenoid> RobotMap::gearGearSolenoid1;
std::shared_ptr<Solenoid> RobotMap::gearGearSolenoid2;
std::shared_ptr<Solenoid> RobotMap::gearStopper;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

void RobotMap::init() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    LiveWindow *lw = LiveWindow::GetInstance();

    intakeIntakeMotor.reset(new TalonSRX(0));
    lw->AddActuator("Intake", "IntakeMotor", std::static_pointer_cast<TalonSRX>(intakeIntakeMotor));
    
    intakeShintake.reset(new TalonSRX(1));
    lw->AddActuator("Intake", "Shintake", std::static_pointer_cast<TalonSRX>(intakeShintake));
    
    intakeIntakeBool.reset(new DigitalInput(8));
    lw->AddSensor("Intake", "IntakeBool", intakeIntakeBool);
    
    climbClimbMotor1.reset(new TalonSRX(2));
    lw->AddActuator("Climb", "ClimbMotor1", std::static_pointer_cast<TalonSRX>(climbClimbMotor1));
    
    climbClimbMotor2.reset(new TalonSRX(3));
    lw->AddActuator("Climb", "ClimbMotor2", std::static_pointer_cast<TalonSRX>(climbClimbMotor2));
    
    climbClimbBool.reset(new DigitalInput(9));
    lw->AddSensor("Climb", "ClimbBool", climbClimbBool);
    
    driveDriveMotor1.reset(new TalonSRX(4));
    lw->AddActuator("Drive", "DriveMotor1", std::static_pointer_cast<TalonSRX>(driveDriveMotor1));
    
    driveDriveMotor2.reset(new TalonSRX(5));
    lw->AddActuator("Drive", "DriveMotor2", std::static_pointer_cast<TalonSRX>(driveDriveMotor2));
    
    driveDriveMotor3.reset(new TalonSRX(6));
    lw->AddActuator("Drive", "DriveMotor 3", std::static_pointer_cast<TalonSRX>(driveDriveMotor3));
    
    driveDriveMotor4.reset(new TalonSRX(7));
    lw->AddActuator("Drive", "DriveMotor 4", std::static_pointer_cast<TalonSRX>(driveDriveMotor4));
    
    driveRobotDrive41.reset(new RobotDrive(driveDriveMotor1, driveDriveMotor2,
              driveDriveMotor3, driveDriveMotor4));
    
    driveRobotDrive41->SetSafetyEnabled(true);
        driveRobotDrive41->SetExpiration(0.1);
        driveRobotDrive41->SetSensitivity(0.5);
        driveRobotDrive41->SetMaxOutput(1.0);

    driveDriveMotor5.reset(new TalonSRX(8));
    lw->AddActuator("Drive", "DriveMotor5", std::static_pointer_cast<TalonSRX>(driveDriveMotor5));
    
    driveDriveMotor6.reset(new TalonSRX(9));
    lw->AddActuator("Drive", "DriveMotor6", std::static_pointer_cast<TalonSRX>(driveDriveMotor6));
    
    driveRobotDrive21.reset(new RobotDrive(driveDriveMotor6, driveDriveMotor5));
    
    driveRobotDrive21->SetSafetyEnabled(true);
        driveRobotDrive21->SetExpiration(0.1);
        driveRobotDrive21->SetSensitivity(0.5);
        driveRobotDrive21->SetMaxOutput(1.0);

    driveEncoder2.reset(new Encoder(2, 3, false, Encoder::k4X));
    lw->AddSensor("Drive", "Encoder2", driveEncoder2);
    driveEncoder2->SetDistancePerPulse(1.0);
    driveEncoder2->SetPIDSourceType(PIDSourceType::kRate);
    driveEncoder3.reset(new Encoder(4, 5, false, Encoder::k4X));
    lw->AddSensor("Drive", "Encoder3", driveEncoder3);
    driveEncoder3->SetDistancePerPulse(1.0);
    driveEncoder3->SetPIDSourceType(PIDSourceType::kRate);
    driveEncoder4.reset(new Encoder(6, 7, false, Encoder::k4X));
    lw->AddSensor("Drive", "Encoder4", driveEncoder4);
    driveEncoder4->SetDistancePerPulse(1.0);
    driveEncoder4->SetPIDSourceType(PIDSourceType::kRate);
    shooterSpeedController1.reset(new Talon(10));
    lw->AddActuator("Shooter", "Speed Controller 1", std::static_pointer_cast<Talon>(shooterSpeedController1));
    
    shooterAnalogInput1.reset(new AnalogInput(0));
    lw->AddSensor("Shooter", "Analog Input 1", shooterAnalogInput1);
    
    shooterPIDController1.reset(new PIDController(1.0, 0.0, 0.0,/* F: 0.0, */ shooterAnalogInput1.get(), shooterSpeedController1.get(), 0.02));
    lw->AddActuator("Shooter", "PID Controller 1", shooterPIDController1);
    shooterPIDController1->SetContinuous(false); shooterPIDController1->SetAbsoluteTolerance(0.2); 
        shooterPIDController1->SetOutputRange(-1.0, 1.0);
    shooterSpeedController2.reset(new Talon(11));
    lw->AddActuator("Shooter", "Speed Controller 2", std::static_pointer_cast<Talon>(shooterSpeedController2));
    
    shooterAnalogInput2.reset(new AnalogInput(1));
    lw->AddSensor("Shooter", "Analog Input 2", shooterAnalogInput2);
    
    shooterPIDController2.reset(new PIDController(1.0, 0.0, 0.0,/* F: 0.0, */ shooterAnalogInput2.get(), shooterSpeedController2.get(), 0.02));
    lw->AddActuator("Shooter", "PID Controller 2", shooterPIDController2);
    shooterPIDController2->SetContinuous(false); shooterPIDController2->SetAbsoluteTolerance(0.2); 
        shooterPIDController2->SetOutputRange(-1.0, 1.0);
    shooterEncoder1.reset(new Encoder(0, 1, false, Encoder::k4X));
    lw->AddSensor("Shooter", "Encoder1", shooterEncoder1);
    shooterEncoder1->SetDistancePerPulse(1.0);
    shooterEncoder1->SetPIDSourceType(PIDSourceType::kRate);
    gearCompressor1.reset(new Compressor(0));
    
    
    gearGearSolenoid1.reset(new Solenoid(0, 0));
    lw->AddActuator("Gear", "GearSolenoid1", gearGearSolenoid1);
    
    gearGearSolenoid2.reset(new Solenoid(0, 1));
    lw->AddActuator("Gear", "GearSolenoid2", gearGearSolenoid2);
    
    gearStopper.reset(new Solenoid(0, 2));
    lw->AddActuator("Gear", "Stopper", gearStopper);
    

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
}
